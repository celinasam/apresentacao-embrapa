 \section{Métodos utilizados nesse Estudo e nessa Implementação}

  \begin{frame}{Álgebra Abstrata e de Códigos Corretores de Erros}
     \begin{itemize}
        \item<1-> \emph{Erasure Coding}
        \item<2-> Exame de Qualificação para o Mestrado (EQM)
        \item<3-> Foco: armazenamento de dados
        \item<4-> Códigos corretores de erro disponíveis na versão 0.22: RAID e RS
        \item<5-> Artigos e material de disciplinas de universidades de Portugal, Índia, Paquistão e EUA
     \end{itemize}
  \end{frame}

  \begin{frame}{Intuições na Álgebra Abstrata}
     \begin{itemize}
        \item<1-> Congruência linear
        \item<2-> Resto da divisão euclidiana
        \item<3-> Independência linear
        \item<4-> Espaço Vetorial, Grupo, Anel e Corpo (principalmente $\mathbb{GF}_2$ e $\mathbb{GF}_{256}$)
        \item<5-> Sistema de Equações Lineares
        \item<6-> Matrizes
        \item<7-> Polinômios
     \end{itemize}
  \end{frame}

  \begin{frame}{Conceitos em Códigos Corretores de Erros}
     \begin{itemize}
        \item<1-> A teoria da codificação estuda as propriedades dos códigos e suas aplicações. O principal objetivo da codificação é projetar eficientes e confiáveis métodos de transmissão e armazenamento de dados.
        \item<2-> Teoria da Informação, Shannon: incerteza e capacidade do canal
        \item<3-> Essa teoria foi desenvolvida por Claude Shannon~\cite{Shannon:1948} para estudar o processamento digital de sinais (sinais em tempo discreto e em tempo contínuo) em um sistema de comunicação, área essa da engenharia elétrica e da matemática aplicada. Esses  sinais podem ser som, áudio, dados biológicos como eletrocardiogramas ou sequências de DNA~\cite{Faria:2010,Faria:2012}, sinais de sistemas de telecomunicações, entre muitos outros.
        \item<4-> Canal binário simétrico
        \item<5-> O objetivo da codificação de canal é aumentar a resistência do sistema de comunicações digital face aos efeitos do ruído de canal.
     \end{itemize}
  \end{frame}

  \begin{frame}{Conceitos em Códigos Corretores de Erros}
     \begin{itemize}
        \item<1-> Detectar e codificar tem a mesma complexidade 
        \item<2-> Decodificar é np-completo
        \item<3-> Estruturas algébricas: matrizes
     \end{itemize}
  \end{frame}

  \begin{frame}{Conhecer e Compilar o código disponível}
     \begin{itemize}
        \item<1-> Facebook, Yahoo, Fundação Apache
        \item<2-> O \emph{kernel} do Hadoop é constituído do core, hdfs e mapred.
        \item<3-> As versões oficiais para instalação (http://www.apache.org/dist/hadoop/core/) e
        \item<4-> as versões do código-fonte (common, hdfs, mapreduce) estão disponíveis em repositório SVN (https://svn.apache.org/repos/asf/hadoop/common/branches/branch-0.22) 
        \item<5-> Na atividade \emph{Scripts for building Hadoop 0.22.0 release}  https://issues.apache.org/jira/browse/HADOOP-6846, os mantenedores e contribuidores do Hadoop discutiam como compilar a versão 0.22
     \end{itemize}
  \end{frame}

  \begin{frame}{Conhecer e Compilar o código disponível}
     \begin{itemize}
        \item<1-> Eclipse
        \item<2-> comandos do linux, principalmente, grep, find
        \item<3-> Doxygen (gerar diagramas de herança e de colaboração das classes a partir do código)
        \item<4-> Implementar uma aplicação do \emph{framework} do Hadoop: conta-palavras, temperatura máxima, \emph{page rank}
        \item<5-> Fazer uma pequena alteração no código do RaidNode () para escrever uma mensagem no arquivo de log, compilar o código modificado, instalá-lo e testá-lo
     \end{itemize}
  \end{frame}

  \begin{frame}{Conhecer e Compilar o código disponível}
     \begin{itemize}
        \item<1-> Hadoop foi escrito quase que inteiramente em Java: construtores de classe, asserções
        \item<2-> Java: 1o capítulo do livro vermelho do Sedgewick, Algorithms
        \item<3-> Entender a camada RAID para poder extendê-la
        \item<4-> Entender de álgebra abstrata e de códigos corretores de erros, uma aplicação em AA
        \item<5-> Propor os algoritmos dos novos \emph{codecs}: \emph{encode} e \emph{decode}
     \end{itemize}
  \end{frame}

  \begin{frame}{Conhecer e Compilar o código disponível}
     \begin{itemize}
        \item<1-> Ambiente de edição do código das classes e de compilação do Hadoop 
        \item<2-> Ambiente de instalação do \emph{tarball}
     \end{itemize}
  \end{frame}

  \begin{frame}{Testes Iniciais}
     \begin{itemize}
        \item<1-> Notebook com Ubuntu $8.04$, $10.04$ ($2GB$ de RAM, \emph{dual-core}, $150MB$ de disco interno, $1.35TB$ de disco externo) 
        \item<2-> Testes funcionais: \emph{encode} e \emph{decode} das novas codificações e correção de erros no código das classes das codificações implementadas por esse trabalho $===>$ linguagem Java.
     \end{itemize}
  \end{frame}

  \begin{frame}{Testes Finais}

     \begin{itemize}
        \item<1-> Instâncias da Amazon EC2 com Ubuntu $12.10$,  \emph{kernel},  ($613MB$ de RAM, \emph{dual-core}, alguns \emph{gigabytes} de disco) 
        \item<2-> 3 fases de Testes de Desempenho (coleta de dados) e de Injeção de Falhas das operações de \emph{encode} e \emph{decode} das novas codificações
        \item<3-> Primeira fase: preparação do ambiente de teste
        \item<4-> Rede de 4 instâncias: 1 \emph{master/slave} e 3 \emph{slaves}
     \end{itemize}
  \end{frame}

  \begin{frame}{Testes Finais}
     \begin{itemize}
              \item<1-> Segunda fase: coleta de dados para medição de desempenho da operações de \emph{encode} e de \emph{decode} para cada codificação:
                  \begin{itemize}
                     \item replicação simples $2X$
                     \item replicação simples $3X$
                     \item $XOR(6,5)$
                     \item $RS(8,5)$
                     \item $Tornado(10,5)$
                     \item $Tornado(20,10)$
                     \item $Turbo-like(10,5)$
                     \item $Turbo-like(20,10)$
                 \end{itemize}
              \item<2-> Rede de 16 instâncias \emph{large}, provavelmente
     \end{itemize}
  \end{frame}

  \begin{frame}{Testes Finais}
     \begin{itemize}
        \item<3-> Terceira fase: coleta de dados para medição da injeção de falhas
           \begin{description}
              \item [falha em $1$ réplica]: corromper $1$ réplica de blocos de dados de um arquivo
              \item [falha em $n$ réplicas] corromper $n$ réplicas de blocos de dados de um arquivo
              \item [falha em réplicas e em blocos de dados] corromper $n$ réplicas de blocos de dados e os $k-1$ blocos de dados de um arquivo
            \end{description}
        \item<4-> Rede de 16 instâncias \emph{large}, provavelmente
     \end{itemize}
  \end{frame}
